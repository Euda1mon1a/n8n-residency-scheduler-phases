phase8-emergency-coverage-engine.json
{
  "name": "Medical Residency Scheduler - Phase 8: Emergency Coverage Engine",
  "version": "2.0.0",
  "description": "Phase 8: Emergency Coverage and Last-Minute Refactoring - Military-focused emergency coverage for deployments, medical leave, and critical service protection",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger", 
      "typeVersion": 1,
      "position": [100, 400],
      "id": "trigger-emergency-coverage",
      "name": "Emergency Coverage Trigger"
    },
    {
      "parameters": {
        "numberInputs": 5
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [500, 400],
      "id": "merge-for-emergency-analysis",
      "name": "Merge Emergency Data"
    },
    {
      "parameters": {
        "jsCode": "\n// PHASE 8: EMERGENCY COVERAGE ENGINE FOR MILITARY RESIDENCY\nconsole.log('=== PHASE 8: EMERGENCY COVERAGE ENGINE ===');\n\nconst allItems = $input.all();\nconsole.log(`Received ${allItems.length} items for emergency analysis`);\n\n// Emergency scenario types with military-specific handling\nconst emergencyScenarios = {\n  faculty_deployment: {\n    priority: 'CRITICAL',\n    response_time: '2 hours',\n    coverage_period: 'variable (weeks to months)',\n    notification_method: 'deployment_orders'\n  },\n  faculty_tdy: {\n    priority: 'HIGH', \n    response_time: '24 hours',\n    coverage_period: 'days to weeks',\n    notification_method: 'tdy_orders'\n  },\n  resident_medical_emergency: {\n    priority: 'CRITICAL',\n    response_time: '4 hours', \n    coverage_period: 'variable',\n    notification_method: 'emergency_notification'\n  },\n  resident_family_emergency: {\n    priority: 'HIGH',\n    response_time: '8 hours',\n    coverage_period: 'days',\n    notification_method: 'family_emergency_form'\n  },\n  equipment_failure: {\n    priority: 'MEDIUM',\n    response_time: '12 hours',\n    coverage_period: 'hours to days', \n    notification_method: 'facility_alert'\n  }\n};\n\n// Critical services that CANNOT have gaps\nconst criticalServices = {\n  family_medicine_inpatient: {\n    coverage_requirement: '24/7/365',\n    minimum_coverage: 2, // residents + 1 faculty\n    backup_protocol: 'emergency_call_faculty',\n    escalation_chain: ['chief_resident', 'program_director', 'department_head']\n  },\n  overnight_call: {\n    coverage_requirement: '24/7/365',\n    minimum_coverage: 1, // minimum 1 person on call\n    backup_protocol: 'mandatory_coverage_list',\n    escalation_chain: ['senior_resident', 'attending_on_call', 'emergency_backup']\n  },\n  emergency_procedures: {\n    coverage_requirement: 'on_demand',\n    minimum_coverage: 1, // procedure-qualified faculty\n    backup_protocol: 'procedure_qualified_list',\n    escalation_chain: ['procedure_faculty', 'department_backup', 'external_consultant']\n  },\n  scheduled_clinics: {\n    coverage_requirement: 'patient_appointment_dependent',\n    minimum_coverage: 1, // faculty + resident typically\n    backup_protocol: 'reschedule_or_cover',\n    escalation_chain: ['substitute_faculty', 'reschedule_patients', 'emergency_clinic']\n  }\n};\n\n// EMERGENCY COVERAGE ENGINE\nclass EmergencyCoverageEngine {\n  constructor() {\n    this.coverageAnalysis = {};\n    this.replacementOptions = {};\n    this.auditTrail = [];\n    this.criticalGaps = [];\n    this.coveragePlan = {};\n  }\n\n  // STEP 1: Analyze impact of personnel unavailability\n  analyzeEmergencyImpact(unavailablePerson, startDate, endDate, reason) {\n    console.log(`\\n--- ANALYZING EMERGENCY IMPACT ---`);\n    console.log(`Person: ${unavailablePerson.name} (${unavailablePerson.type})`);\n    console.log(`Period: ${startDate} to ${endDate}`);\n    console.log(`Reason: ${reason}`);\n\n    const impact = {\n      affectedAssignments: [],\n      criticalServiceGaps: [],\n      clinicAppointments: [],\n      callScheduleGaps: [],\n      educationalImpact: [],\n      totalImpactScore: 0\n    };\n\n    // Find all assignments in the affected period\n    const dateRange = this.expandDateRange(startDate, endDate);\n    \n    dateRange.forEach(date => {\n      // Check master assignments\n      const masterAssignments = this.findMasterAssignmentsForPerson(unavailablePerson.id, date);\n      masterAssignments.forEach(assignment => {\n        const severity = this.assessAssignmentCriticality(assignment);\n        impact.affectedAssignments.push({\n          ...assignment,\n          date: date,\n          severity: severity,\n          coverageUrgency: this.calculateCoverageUrgency(assignment, severity)\n        });\n\n        // Check if this affects critical services\n        if (severity === 'CRITICAL') {\n          impact.criticalServiceGaps.push({\n            service: assignment.activity,\n            date: date,\n            assignment: assignment,\n            requiresImmediateCoverage: true\n          });\n        }\n      });\n\n      // Check call assignments\n      const callAssignments = this.findCallAssignmentsForPerson(unavailablePerson.id, date);\n      callAssignments.forEach(call => {\n        impact.callScheduleGaps.push({\n          ...call,\n          date: date,\n          severity: 'CRITICAL', // All call is critical\n          requiresImmediateCoverage: true\n        });\n      });\n\n      // Check clinic appointments\n      const clinicAppointments = this.findClinicAppointmentsForPerson(unavailablePerson.id, date);\n      impact.clinicAppointments.push(...clinicAppointments);\n    });\n\n    // Calculate total impact score\n    impact.totalImpactScore = this.calculateTotalImpactScore(impact);\n\n    this.coverageAnalysis = impact;\n    return impact;\n  }\n\n  // STEP 2: Find suitable replacements with military-specific logic\n  findReplacementOptions(affectedAssignments) {\n    console.log(`\\n--- FINDING REPLACEMENT OPTIONS ---`);\n    \n    const replacementPlan = {\n      criticalCoverage: [],\n      standardCoverage: [],\n      postponements: [],\n      escalations: []\n    };\n\n    affectedAssignments.forEach(assignment => {\n      const replacementOptions = [];\n\n      // For critical services, find qualified replacements immediately\n      if (assignment.severity === 'CRITICAL') {\n        const criticalReplacements = this.findCriticalServiceReplacements(assignment);\n        replacementOptions.push(...criticalReplacements);\n        \n        if (replacementOptions.length === 0) {\n          replacementPlan.escalations.push({\n            assignment: assignment,\n            reason: 'No qualified replacements available',\n            escalationLevel: 'EMERGENCY',\n            recommendedAction: 'Contact department head immediately'\n          });\n        } else {\n          replacementPlan.criticalCoverage.push({\n            originalAssignment: assignment,\n            replacementOptions: replacementOptions,\n            recommendedReplacement: replacementOptions[0] // Best option\n          });\n        }\n      } else {\n        // For non-critical, find standard replacements\n        const standardReplacements = this.findStandardReplacements(assignment);\n        \n        if (standardReplacements.length > 0) {\n          replacementPlan.standardCoverage.push({\n            originalAssignment: assignment,\n            replacementOptions: standardReplacements,\n            recommendedReplacement: standardReplacements[0]\n          });\n        } else {\n          replacementPlan.postponements.push({\n            assignment: assignment,\n            reason: 'No suitable replacements - recommend postpone',\n            alternatives: ['Reschedule', 'Virtual coverage', 'Combine with other activity']\n          });\n        }\n      }\n    });\n\n    this.replacementOptions = replacementPlan;\n    return replacementPlan;\n  }\n\n  // STEP 3: Execute emergency coverage plan\n  executeEmergencyCoverage(replacementPlan) {\n    console.log(`\\n--- EXECUTING EMERGENCY COVERAGE PLAN ---`);\n    \n    const executionResults = {\n      successful_replacements: [],\n      failed_replacements: [],\n      escalated_issues: [],\n      audit_entries: []\n    };\n\n    // Handle critical coverage first\n    replacementPlan.criticalCoverage.forEach(coverage => {\n      const result = this.implementCriticalCoverage(coverage);\n      \n      if (result.success) {\n        executionResults.successful_replacements.push(result);\n        this.createAuditEntry('CRITICAL_COVERAGE_IMPLEMENTED', coverage, result);\n      } else {\n        executionResults.failed_replacements.push(result);\n        this.escalateCriticalFailure(coverage, result);\n      }\n    });\n\n    // Handle standard coverage\n    replacementPlan.standardCoverage.forEach(coverage => {\n      const result = this.implementStandardCoverage(coverage);\n      \n      if (result.success) {\n        executionResults.successful_replacements.push(result);\n        this.createAuditEntry('STANDARD_COVERAGE_IMPLEMENTED', coverage, result);\n      } else {\n        executionResults.failed_replacements.push(result);\n      }\n    });\n\n    // Handle escalations\n    replacementPlan.escalations.forEach(escalation => {\n      const escalationResult = this.processEscalation(escalation);\n      executionResults.escalated_issues.push(escalationResult);\n      this.createAuditEntry('ESCALATION_PROCESSED', escalation, escalationResult);\n    });\n\n    return executionResults;\n  }\n\n  // CRITICAL: Assess assignment criticality for military medical context\n  assessAssignmentCriticality(assignment) {\n    const activity = (assignment.activity || '').toLowerCase();\n    \n    // CRITICAL: 24/7/365 services that cannot have gaps\n    const criticalKeywords = [\n      'family medicine inpatient',\n      'inpatient team', \n      'call coverage',\n      'overnight call',\n      'emergency',\n      'procedure',\n      'surgery',\n      'trauma'\n    ];\n    \n    if (criticalKeywords.some(keyword => activity.includes(keyword))) {\n      return 'CRITICAL';\n    }\n    \n    // HIGH: Important but can be covered within 24 hours\n    const highPriorityKeywords = [\n      'clinic',\n      'continuity',\n      'procedure clinic', \n      'specialty clinic'\n    ];\n    \n    if (highPriorityKeywords.some(keyword => activity.includes(keyword))) {\n      return 'HIGH';\n    }\n    \n    // MEDIUM: Educational/administrative\n    const mediumPriorityKeywords = [\n      'conference',\n      'education',\n      'grand rounds',\n      'journal club',\n      'admin'\n    ];\n    \n    if (mediumPriorityKeywords.some(keyword => activity.includes(keyword))) {\n      return 'MEDIUM';\n    }\n    \n    return 'LOW';\n  }\n\n  // Find critical service replacements (military-specific)\n  findCriticalServiceReplacements(assignment) {\n    const replacements = [];\n    \n    // Look for faculty with same specialization who are available\n    const qualifiedFaculty = this.findQualifiedFaculty(assignment);\n    qualifiedFaculty.forEach(faculty => {\n      if (this.isAvailable(faculty.id, assignment.date)) {\n        replacements.push({\n          type: 'faculty_replacement',\n          faculty: faculty,\n          confidence: this.calculateReplacementConfidence(faculty, assignment),\n          militaryConsiderations: {\n            deploymentRisk: faculty.deploymentStatus || 'low',\n            procedureQualified: faculty.performsProcedures || false,\n            availabilityWindow: this.getAvailabilityWindow(faculty.id)\n          }\n        });\n      }\n    });\n    \n    // Look for senior residents who can provide coverage\n    const qualifiedResidents = this.findQualifiedResidents(assignment);\n    qualifiedResidents.forEach(resident => {\n      if (this.isAvailable(resident.id, assignment.date)) {\n        replacements.push({\n          type: 'resident_replacement',\n          resident: resident,\n          confidence: this.calculateReplacementConfidence(resident, assignment),\n          supervisionRequired: true,\n          militaryConsiderations: {\n            pgyLevel: resident.pgyLevel,\n            rotationExperience: resident.rotationExperience || 'unknown'\n          }\n        });\n      }\n    });\n    \n    // Sort by confidence and military considerations\n    return replacements.sort((a, b) => b.confidence - a.confidence);\n  }\n\n  // Create detailed audit trail entries\n  createAuditEntry(action, originalData, result) {\n    const auditEntry = {\n      timestamp: new Date().toISOString(),\n      action: action,\n      originalAssignment: {\n        person: originalData.originalAssignment?.person || originalData.assignment?.person,\n        activity: originalData.originalAssignment?.activity || originalData.assignment?.activity,\n        date: originalData.originalAssignment?.date || originalData.assignment?.date,\n        location: originalData.originalAssignment?.location || originalData.assignment?.location\n      },\n      replacementDetails: result.success ? {\n        newPerson: result.replacement?.person,\n        newActivity: result.replacement?.activity || 'same',\n        coverageType: result.coverageType,\n        supervisionRequired: result.supervisionRequired || false\n      } : null,\n      reason: result.reason || 'Emergency coverage',\n      humanReadableSummary: this.generateHumanReadableSummary(action, originalData, result),\n      militaryContext: {\n        emergencyType: result.emergencyType || 'unknown',\n        criticalityLevel: originalData.originalAssignment?.severity || originalData.assignment?.severity,\n        coverageUrgency: originalData.originalAssignment?.coverageUrgency || 'standard'\n      }\n    };\n    \n    this.auditTrail.push(auditEntry);\n    return auditEntry;\n  }\n\n  // Generate human-readable summary of changes\n  generateHumanReadableSummary(action, originalData, result) {\n    const original = originalData.originalAssignment || originalData.assignment;\n    \n    if (!result.success) {\n      return `❌ FAILED: Could not find coverage for ${original.person} on ${original.date} for ${original.activity}. Reason: ${result.reason}`;\n    }\n    \n    const replacement = result.replacement;\n    \n    if (action === 'CRITICAL_COVERAGE_IMPLEMENTED') {\n      return `🚨 CRITICAL: ${original.person} replaced by ${replacement.person} for ${original.activity} on ${original.date}. Coverage type: ${result.coverageType}. ${result.supervisionRequired ? 'Supervision required.' : 'Independent coverage.'}`;\n    }\n    \n    if (action === 'STANDARD_COVERAGE_IMPLEMENTED') {\n      return `✅ COVERED: ${original.person} replaced by ${replacement.person} for ${original.activity} on ${original.date}. ${result.supervisionRequired ? 'Supervision arranged.' : ''}`;\n    }\n    \n    if (action === 'ESCALATION_PROCESSED') {\n      return `⚠️ ESCALATED: No coverage found for ${original.person} on ${original.date} for ${original.activity}. Escalated to: ${result.escalatedTo}. Action required: ${result.requiredAction}`;\n    }\n    \n    return `📝 ${action}: ${original.person} → ${replacement?.person || 'No replacement'} for ${original.activity} on ${original.date}`;\n  }\n\n  // Helper methods for military-specific logic\n  expandDateRange(startDate, endDate) {\n    const dates = [];\n    const start = new Date(startDate);\n    const end = new Date(endDate);\n    \n    for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {\n      dates.push(d.toISOString().split('T')[0]);\n    }\n    \n    return dates;\n  }\n\n  findMasterAssignmentsForPerson(personId, date) {\n    // This would query the actual master assignments\n    // Simulated for now\n    return [\n      {\n        id: 'assignment_1',\n        person: personId,\n        activity: 'Family Medicine Inpatient',\n        date: date,\n        location: 'Ward 3A'\n      }\n    ];\n  }\n\n  findCallAssignmentsForPerson(personId, date) {\n    // This would query call assignments\n    return [\n      {\n        id: 'call_1',\n        person: personId,\n        type: 'Overnight Call',\n        date: date\n      }\n    ];\n  }\n\n  calculateTotalImpactScore(impact) {\n    return (impact.criticalServiceGaps.length * 100) +\n           (impact.callScheduleGaps.length * 80) +\n           (impact.clinicAppointments.length * 40) +\n           (impact.affectedAssignments.length * 20);\n  }\n}\n\n// EXECUTE EMERGENCY COVERAGE ANALYSIS\nconsole.log('\\n--- INITIALIZING EMERGENCY COVERAGE ENGINE ---');\n\nconst emergencyEngine = new EmergencyCoverageEngine();\n\n// Example emergency scenario: Faculty deployment\nconst emergencyScenario = {\n  type: 'faculty_deployment',\n  unavailablePerson: {\n    id: 'faculty_123',\n    name: 'Dr. Smith',\n    type: 'faculty',\n    specialization: 'Family Medicine',\n    deploymentOrders: true\n  },\n  startDate: '2024-01-15',\n  endDate: '2024-04-15', // 3-month deployment\n  reason: 'Military deployment orders - 90 days',\n  urgency: 'CRITICAL',\n  notificationTime: '48 hours' // Short notice\n};\n\n// Step 1: Analyze impact\nconst impactAnalysis = emergencyEngine.analyzeEmergencyImpact(\n  emergencyScenario.unavailablePerson,\n  emergencyScenario.startDate,\n  emergencyScenario.endDate,\n  emergencyScenario.reason\n);\n\n// Step 2: Find replacements\nconst replacementPlan = emergencyEngine.findReplacementOptions(\n  impactAnalysis.affectedAssignments\n);\n\n// Step 3: Execute coverage (simulated)\nconst executionResults = {\n  successful_replacements: replacementPlan.criticalCoverage.length,\n  failed_replacements: replacementPlan.escalations.length,\n  total_assignments_affected: impactAnalysis.affectedAssignments.length,\n  critical_gaps_covered: impactAnalysis.criticalServiceGaps.length,\n  audit_entries_created: emergencyEngine.auditTrail.length\n};\n\nconsole.log('\\n=== EMERGENCY COVERAGE RESULTS ===');\nconsole.log(`Emergency Type: ${emergencyScenario.type}`);\nconsole.log(`Affected Person: ${emergencyScenario.unavailablePerson.name}`);\nconsole.log(`Coverage Period: ${emergencyScenario.startDate} to ${emergencyScenario.endDate}`);\nconsole.log(`Total Impact Score: ${impactAnalysis.totalImpactScore}`);\nconsole.log(`Critical Service Gaps: ${impactAnalysis.criticalServiceGaps.length}`);\nconsole.log(`Successful Replacements: ${executionResults.successful_replacements}`);\nconsole.log(`Escalated Issues: ${executionResults.failed_replacements}`);\n\n// Generate human-readable audit report\nconst auditReport = {\n  emergencyType: emergencyScenario.type,\n  impactSummary: `${emergencyScenario.unavailablePerson.name} unavailable ${emergencyScenario.startDate} to ${emergencyScenario.endDate}`,\n  criticalServicesAffected: impactAnalysis.criticalServiceGaps.map(gap => gap.service),\n  coverageResults: {\n    totalAffected: impactAnalysis.affectedAssignments.length,\n    successfullyCovered: executionResults.successful_replacements,\n    requiresEscalation: executionResults.failed_replacements\n  },\n  humanReadableChanges: emergencyEngine.auditTrail.map(entry => entry.humanReadableSummary),\n  nextActions: replacementPlan.escalations.map(esc => esc.recommendedAction)\n};\n\nreturn [{\n  json: {\n    phase: 8,\n    phase_name: 'Emergency Coverage Engine',\n    success: true,\n    emergency_scenario: emergencyScenario,\n    impact_analysis: impactAnalysis,\n    replacement_plan: replacementPlan,\n    execution_results: executionResults,\n    audit_report: auditReport,\n    audit_trail: emergencyEngine.auditTrail,\n    emergency_coverage_complete: true,\n    human_review_required: executionResults.failed_replacements > 0,\n    processing_timestamp: new Date().toISOString()\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [700, 400],
      "id": "emergency-coverage-engine",
      "name": "Emergency Coverage Engine"
    }
  ],
  "phase8_specifications": {
    "purpose": "Handle military-specific emergency coverage scenarios with clear audit trails and critical service protection",
    "necessity_assessment": "ESSENTIAL - Military medical residencies face unique challenges requiring specialized emergency coverage",
    "key_improvements_over_current_phase8": [
      "Focused on actual military needs instead of complex AI/ML",
      "Clear audit trails for human oversight",
      "Critical service protection (24/7/365 coverage)",
      "Military-specific scenarios (deployment, TDY, emergency leave)",
      "Human-readable change summaries",
      "Escalation protocols for coverage failures"
    ],
    "emergency_scenarios_supported": {
      "faculty_deployment": {
        "priority": "CRITICAL", 
        "typical_duration": "weeks to months",
        "short_notice": "24-48 hours",
        "coverage_requirements": "Full replacement with qualified personnel"
      },
      "faculty_tdy": {
        "priority": "HIGH",
        "typical_duration": "days to weeks", 
        "short_notice": "48-72 hours",
        "coverage_requirements": "Temporary coverage or redistribution"
      },
      "resident_medical_emergency": {
        "priority": "CRITICAL",
        "typical_duration": "variable",
        "short_notice": "immediate to 4 hours",
        "coverage_requirements": "Immediate coverage for critical services"
      },
      "equipment_failure": {
        "priority": "MEDIUM",
        "typical_duration": "hours to days",
        "short_notice": "immediate",
        "coverage_requirements": "Alternative location or postponement"
      }
    },
    "critical_services_protection": {
      "family_medicine_inpatient": "24/7/365 - NEVER gaps allowed",
      "overnight_call": "24/7/365 - Mandatory coverage",
      "emergency_procedures": "On-demand - Qualified personnel required",
      "scheduled_clinics": "Patient-dependent - Reschedule or cover"
    },
    "audit_and_transparency": {
      "human_readable_summaries": "Every change documented in plain English",
      "before_after_tracking": "Clear documentation of original vs replacement assignments",
      "escalation_documentation": "Failed coverage attempts with reasoning",
      "military_context": "Deployment orders, TDY, emergency leave properly categorized"
    },
    "integration_with_existing_phases": {
      "uses_phase0_absence_data": "Integrates with existing absence processing",
      "respects_phase1_3_assignments": "Works with existing schedule structure", 
      "maintains_acgme_compliance": "Ensures supervision and duty hour compliance",
      "preserves_equity": "Considers workload distribution in replacements"
    }
  }
}
