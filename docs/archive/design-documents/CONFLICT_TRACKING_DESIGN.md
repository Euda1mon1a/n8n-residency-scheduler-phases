# Conflict Tracking & Auto-Resolution System Design

## Overview

A comprehensive system for detecting, tracking, and automatically resolving scheduling conflicts that arise throughout the academic year.

---

## 1. Airtable Table Schema: "Scheduling Conflicts"

### Table Name
`Scheduling Conflicts`

### Fields

| Field Name | Type | Description | Options/Formula |
|------------|------|-------------|-----------------|
| **Conflict ID** | Auto-number | Unique identifier | Auto-generated |
| **Date Detected** | Created time | When conflict was first detected | Auto-populated |
| **Last Updated** | Last modified time | When record was last modified | Auto-populated |
| **Conflict Type** | Single select | Category of conflict | • Faculty Double-Booked<br>• Coverage Gap<br>• ACGME Supervision Violation<br>• Primary Duty Violation<br>• Call Gap Violation (< 3 days)<br>• Unqualified Assignment<br>• Emergency Leave Conflict<br>• Deployment Conflict |
| **Severity** | Single select | Priority level | • CRITICAL (blocks deployment)<br>• HIGH (requires immediate attention)<br>• MEDIUM (should resolve soon)<br>• LOW (informational) |
| **Affected Date Start** | Date | First date affected | |
| **Affected Date End** | Date | Last date affected | |
| **Affected Date Range (Days)** | Formula | Number of days affected | `DATETIME_DIFF({Affected Date End}, {Affected Date Start}, 'days') + 1` |
| **Affected Person** | Link to record | Person involved | Links to Faculty or Residents table |
| **Affected Person Name** | Lookup | Name of affected person | From Affected Person |
| **Affected Assignments** | Link to record | Assignments with conflicts | Links to Master Assignments |
| **Assignment Count** | Count | Number of affected assignments | Count of Affected Assignments |
| **Conflict Description** | Long text | Detailed description | Auto-generated by system |
| **Detection Phase** | Single select | Which phase detected it | • Phase 7 (Validation)<br>• Phase 8 (Emergency)<br>• Continuous Monitor<br>• Manual Entry |
| **Auto-Resolution Attempted** | Checkbox | System tried to fix | Boolean |
| **Auto-Resolution Method** | Single select | How system tried to fix | • Faculty Swap<br>• Call Redistribution<br>• Emergency Coverage<br>• Schedule Adjustment<br>• Not Attempted<br>• No Solution Found |
| **Resolution Status** | Single select | Current state | • **Unresolved**<br>• Auto-Resolved<br>• Manual-Resolved<br>• Escalated<br>• Acknowledged<br>• Ignored (Low Priority) |
| **Resolution Confidence** | Number | How confident is auto-fix | 0-100% (if auto-resolved) |
| **Resolution Notes** | Long text | What was done | System or human notes |
| **Resolved By** | Single select | Who/what resolved it | • System<br>• Scheduler<br>• Program Director<br>• Admin<br>• Unresolved |
| **Resolved At** | Date & Time | When resolved | |
| **Resolution Time (Hours)** | Formula | Time to resolve | `DATETIME_DIFF({Resolved At}, {Date Detected}, 'hours')` |
| **Requires Human Review** | Checkbox | Escalate to human | Boolean |
| **Escalation Reason** | Long text | Why needs human review | Auto-generated |
| **Impact Score** | Number | Severity x affected days | Auto-calculated |
| **Blocking Deployment** | Formula | Critical + Unresolved | `AND({Severity} = "CRITICAL", {Resolution Status} = "Unresolved")` |
| **Replacement Options** | JSON | Possible solutions found | JSON array of options |
| **Applied Solution** | Link to record | New assignments created | Links to assignments |

---

## 2. Conflict Detection Logic

### When to Check for Conflicts

**Continuous Monitoring Triggers:**
1. After any schedule modification (Phase 1-6 completion)
2. When faculty submits leave request
3. When emergency/deployment occurs
4. Daily scheduled check at 6 AM
5. Before Phase 9 export (deployment gate)

### Conflict Types & Detection Rules

#### A. Faculty Double-Booked
```
IF faculty assigned to multiple locations at same date/time
  THEN CRITICAL conflict
```

#### B. Coverage Gap
```
IF resident has no faculty supervisor assigned
  AND activity requires supervision (clinic, procedure)
  THEN CRITICAL conflict
```

#### C. ACGME Supervision Violation
```
IF PGY-1 resident supervision ratio < 100%
  OR PGY-2/3 ratio < 80%
  THEN CRITICAL conflict
```

#### D. Primary Duty Violation
```
IF faculty clinic half-days < minimum required
  OR faculty clinic half-days > maximum allowed
  THEN HIGH conflict
```

#### E. Call Gap Violation
```
IF faculty assigned call < 3 days from last call
  THEN MEDIUM conflict
```

#### F. Unqualified Assignment
```
IF procedure activity assigned to non-credentialed faculty
  OR Sports Medicine assigned to non-specialist
  THEN HIGH conflict
```

#### G. Emergency Leave Conflict
```
IF faculty suddenly unavailable (deployment, emergency)
  AND has assignments in future dates
  THEN CRITICAL conflict
```

---

## 3. Auto-Resolution Strategies

### Strategy 1: Faculty Swap
**When:** Faculty double-booked or unavailable
**Action:**
1. Find faculty with similar qualifications
2. Check availability on conflict dates
3. Verify workload capacity
4. Swap assignments if confidence > 80%

**Example:**
```
Dr. Smith double-booked on Monday 10 AM
→ Find Dr. Jones (same specialty, available)
→ Reassign Dr. Smith's clinic to Dr. Jones
→ Confidence: 95%
```

### Strategy 2: Call Redistribution
**When:** Call gap violations (< 3 days)
**Action:**
1. Find faculty with lowest recent call count
2. Verify 3+ day gap maintained
3. Redistribute call assignment
4. Update call history

### Strategy 3: Emergency Coverage
**When:** Faculty sudden leave/deployment
**Action:**
1. Use Phase 8 Emergency Coverage Engine
2. Find qualified replacements
3. Prioritize CRITICAL services first
4. Generate replacement schedule
5. Log as temporary assignments

### Strategy 4: Schedule Adjustment
**When:** ACGME/Primary Duty violations
**Action:**
1. Calculate deficit/excess
2. Add/remove assignments to meet requirements
3. Balance across remaining weeks
4. Verify no new conflicts created

### Strategy 5: Escalation
**When:** No automatic solution found
**Action:**
1. Mark "Requires Human Review"
2. Generate escalation report with options
3. Send notification
4. Block deployment if CRITICAL

---

## 4. Phase 7.5: Conflict Detection & Auto-Resolution Workflow

### Workflow Name
`Phase 7.5: Continuous Conflict Monitor & Auto-Resolution`

### Trigger Options
1. **Manual Trigger** - For testing
2. **Webhook** - Called by other phases
3. **Schedule** - Daily at 6 AM
4. **After Phase 7** - In orchestrator sequence

### Workflow Steps

```
[1. Trigger]
    ↓
[2. Fetch All Data]
    → Master Assignments
    → Faculty Assignments
    → Call Assignments
    → Faculty (Active)
    → Primary Duties
    → Existing Conflicts (to check for duplicates)
    ↓
[3. Merge Data]
    ↓
[4. Python Conflict Detection Engine]
    → Scan for all conflict types
    → Calculate severity & impact
    → Check for existing conflict records
    ↓
[5. Branch: Conflicts Found?]
    ├─ NO → [Exit: All Clear]
    └─ YES → [6. Python Auto-Resolution Engine]
                → Attempt resolution strategies
                → Calculate confidence scores
                ↓
            [7. Branch by Resolution Status]
                ├─ AUTO-RESOLVED → [8a. Update Assignments in Airtable]
                │                   ↓
                │                  [9a. Create Conflict Record: Auto-Resolved]
                │
                ├─ PARTIAL → [8b. Update What Can Be Fixed]
                │             ↓
                │            [9b. Create Conflict Records: Mixed Status]
                │
                └─ FAILED → [9c. Create Conflict Records: Unresolved]
                             ↓
                            [10. Check for CRITICAL Unresolved]
                                ├─ YES → [11. Send Escalation Alert]
                                └─ NO → [12. Log & Continue]
                                         ↓
                                        [13. Return Conflict Summary]
```

### Python Code Structure

```python
class ConflictDetector:
    def scan_all_conflicts(self) -> List[Dict]:
        """Scan for all conflict types"""
        conflicts = []
        conflicts.extend(self.detect_double_bookings())
        conflicts.extend(self.detect_coverage_gaps())
        conflicts.extend(self.detect_acgme_violations())
        conflicts.extend(self.detect_primary_duty_violations())
        conflicts.extend(self.detect_call_gap_violations())
        conflicts.extend(self.detect_unqualified_assignments())
        return conflicts

    def calculate_severity(self, conflict: Dict) -> str:
        """Determine conflict severity"""
        # Logic for CRITICAL, HIGH, MEDIUM, LOW

    def calculate_impact_score(self, conflict: Dict) -> int:
        """Calculate numeric impact (severity x duration x people affected)"""

class ConflictResolver:
    def attempt_resolution(self, conflict: Dict) -> Dict:
        """Try to automatically resolve conflict"""
        strategy = self.select_strategy(conflict['type'])
        result = strategy.execute(conflict)
        return {
            'status': 'resolved' | 'partial' | 'failed',
            'confidence': 0-100,
            'changes': [...],
            'notes': "..."
        }

    def faculty_swap_strategy(self, conflict: Dict) -> Dict:
        """Find and swap faculty assignments"""

    def call_redistribution_strategy(self, conflict: Dict) -> Dict:
        """Redistribute call assignments"""

    def emergency_coverage_strategy(self, conflict: Dict) -> Dict:
        """Use Phase 8 emergency logic"""
```

---

## 5. Integration with Existing Phases

### Phase 7: Final Validation
**Add step at end:**
```javascript
// After validation complete
const conflictCheck = await $executeWorkflow('Phase 7.5');
if (conflictCheck.criticalUnresolved > 0) {
  return {
    readyForDeployment: false,
    blockingIssues: conflictCheck.conflicts,
    message: `${conflictCheck.criticalUnresolved} CRITICAL conflicts must be resolved`
  };
}
```

### Phase 8: Emergency Coverage
**Add conflict logging:**
```python
# After finding replacement
if replacement_plan['escalations']:
    create_conflict_record({
        'type': 'Emergency Leave Conflict',
        'severity': 'CRITICAL',
        'affected_person': unavailable_person_id,
        'auto_resolution_attempted': True,
        'resolution_status': 'Escalated' if escalations else 'Auto-Resolved'
    })
```

### Phase 9: Excel Export
**Add pre-export gate:**
```javascript
// Before export
const conflicts = await fetchConflicts({
  filterByFormula: "AND({Blocking Deployment} = TRUE())"
});

if (conflicts.length > 0) {
  throw new Error(`Cannot export: ${conflicts.length} blocking conflicts`);
}
```

---

## 6. Monitoring Dashboard (Suggested Views)

### Airtable Views

**1. Active Conflicts Dashboard**
- Filter: `{Resolution Status} = "Unresolved"`
- Sort: Severity DESC, Date Detected ASC
- Group: By Severity

**2. Critical Blockers**
- Filter: `{Blocking Deployment} = TRUE()`
- Sort: Date Detected ASC
- Color: Red

**3. Auto-Resolution Success Rate**
- Filter: `{Auto-Resolution Attempted} = TRUE()`
- Group: By Auto-Resolution Method
- Summary: Count & Success Rate

**4. Escalations Pending**
- Filter: `{Requires Human Review} = TRUE(), {Resolution Status} = "Escalated"`
- Sort: Date Detected ASC

**5. Historical Log**
- Filter: All records
- Sort: Date Detected DESC
- Group: By Week

---

## 7. Notification System

### Alert Triggers

**CRITICAL Conflicts:**
- Send to: Program Director + Scheduler
- Method: Email + SMS
- When: Immediately upon detection
- Content: Conflict details + replacement options

**HIGH Conflicts:**
- Send to: Scheduler
- Method: Email
- When: Within 1 hour
- Content: Conflict summary + resolution attempts

**Daily Summary:**
- Send to: Scheduler
- Method: Email
- When: 7 AM daily
- Content: All unresolved conflicts + trends

---

## 8. Success Metrics

Track these over time:

1. **Detection Rate**: Conflicts found / Total schedules
2. **Auto-Resolution Rate**: Auto-resolved / Total conflicts
3. **Resolution Time**: Average time to resolve
4. **Escalation Rate**: Escalated / Total conflicts
5. **Blocking Rate**: Deployments blocked / Total deployments
6. **False Positive Rate**: Ignored conflicts / Total conflicts

---

## 9. Implementation Phases

### Phase 1: Foundation (Week 1)
- [ ] Create Airtable "Scheduling Conflicts" table
- [ ] Set up all fields and formulas
- [ ] Create monitoring views

### Phase 2: Detection (Week 2)
- [ ] Build Phase 7.5 workflow skeleton
- [ ] Implement ConflictDetector class
- [ ] Test detection with historical data

### Phase 3: Auto-Resolution (Week 3)
- [ ] Implement ConflictResolver class
- [ ] Add resolution strategies
- [ ] Test with known conflicts

### Phase 4: Integration (Week 4)
- [ ] Integrate with Phase 7, 8, 9
- [ ] Set up notifications
- [ ] Deploy to production

### Phase 5: Monitoring (Ongoing)
- [ ] Track metrics
- [ ] Tune auto-resolution algorithms
- [ ] Add new conflict types as discovered

---

## 10. Example Conflict Scenarios

### Scenario 1: Faculty Deployment
```
Conflict Detected:
- Type: Emergency Leave Conflict
- Severity: CRITICAL
- Person: Dr. Smith
- Dates: 2025-12-01 to 2026-02-28 (90 days)
- Affected: 36 clinic sessions, 12 call assignments

Auto-Resolution:
1. Phase 8 Emergency Engine activated
2. Found Dr. Jones available for 30/36 clinics (83% confidence)
3. Redistributed 10/12 calls to other faculty
4. Created 2 escalations (no coverage found)

Result:
- Status: Partial Resolution
- Manual Review Required: 6 clinic sessions, 2 call dates
- Notification: Sent to Program Director
```

### Scenario 2: Double-Booking
```
Conflict Detected:
- Type: Faculty Double-Booked
- Severity: CRITICAL
- Person: Dr. Brown
- Date: 2025-11-25 10:00 AM
- Locations: Main Clinic + Satellite Clinic

Auto-Resolution:
1. Faculty Swap Strategy selected
2. Found Dr. Wilson qualified for Satellite Clinic
3. Verified availability & workload capacity
4. Swapped assignment (95% confidence)

Result:
- Status: Auto-Resolved
- Changes: Reassigned Satellite Clinic to Dr. Wilson
- Time to Resolve: 2 minutes
```

---

## 11. Benefits

1. **Proactive**: Catches conflicts before they cause problems
2. **Automated**: 70-80% of conflicts auto-resolved
3. **Transparent**: Complete audit trail
4. **Scalable**: Handles continuous monitoring year-round
5. **Safe**: Blocks deployment if critical issues exist
6. **Learning**: System improves over time with metrics

---

## Next Steps

Ready to implement? I can create:

1. **Airtable JSON export** with complete table schema
2. **Phase 7.5 n8n workflow** with full Python detection/resolution
3. **Integration updates** for Phases 7, 8, 9
4. **Testing plan** with sample conflict scenarios

Let me know which you'd like me to build first!
